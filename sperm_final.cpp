#include "opencv2/imgcodecs/imgcodecs.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/videoio/videoio.hpp"
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/video.hpp>
#include <opencv2/tracking/tracking.hpp>
#include <opencv2/core/ocl.hpp>
#include <chrono>
#include <opencv2/core/utility.hpp>
#include <opencv2/tracking.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/highgui.hpp>
#include <iostream>
#include <cstring>

//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
using namespace cv;
using namespace std;
using namespace std::chrono;



#define SSTR( x ) static_cast< std::ostringstream & >( \
( std::ostringstream() << std::dec << x ) ).str()

// Global variables
RNG rng(12345);
Mat Finalpath;
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Mat pathdrawing, colorFgMask;
vector<vector<Point2f> >allMoments;
vector<Point2f>travelled;
vector<int>fastSperm, slowSperm;
int keyboard;
Ptr<cv::BackgroundSubtractorMOG2> pMOG2; //MOG2 Background subtractor
void trackAll(const char* v);
//void trackSpecific(const char* videoFilename);
//void trackSpecific(const char* videoFilename);
Point calculateBlobCentroid(vector<Point>blob);
void trackIndi(int i, Rect2d bbox, char* videoFilename , vector<vector<Point>> contours , int t);
float dist(Point2f p, Point2f q);
Scalar color;

Mat frame1;


//--------------------------------Main Function---------------------------------//
int main(int argc, char* argv[])
{
	//---------------------to make new video of less frames------------------- 

	vector<Mat> all_frames;
	VideoCapture cap_new("1sec.avi");

	// Check if camera opened successfully
	if (!cap_new.isOpened()) {
		cout << "Error opening video stream or file" << endl;
		return -1;
	}
	int co = 0;
	while (1)
	{

		Mat frame_;
		// Capture frame-by-frame
		cap_new >> frame_;

		// If the frame is empty, break immediately
		if (frame_.empty())
			break;
		all_frames.push_back(frame_);
		co++;
		
	}
	cout << co << endl;
	int frame_width = cap_new.get(CAP_PROP_FRAME_WIDTH);
	int frame_height = cap_new.get(CAP_PROP_FRAME_HEIGHT);
	VideoWriter video("outcpp.avi", cv::VideoWriter::fourcc('M', 'J', 'P', 'G'), 5 , Size(frame_width, frame_height));
	video.write(all_frames[0]);
	video.write(all_frames[1]);
	video.write(all_frames[5]);
	video.write(all_frames[6]);
	video.write(all_frames[10]);
	video.write(all_frames[15]);
	video.write(all_frames[20]);
	video.write(all_frames[21]);
	video.write(all_frames[23]);
	video.write(all_frames[24]);
	// When everything done, release the video capture object
	cap_new.release();
	waitKey(0);



	//------------------------------------------------------------------------

	VideoCapture cap1("1sec.avi");
	cap1.read(frame1);

	//for calculating Run time of the program
	auto start = high_resolution_clock::now();

	//create Background Subtractor objects
	pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
	namedWindow("fg", WINDOW_NORMAL);
	resizeWindow("fg", 600, 600);
	trackAll("outcpp.avi");

	auto stop = high_resolution_clock::now();
	auto duration = duration_cast<microseconds>(stop - start);
	cout << "Time taken by function: "
		<< (duration.count() / 1000000) / 60 << "-Min "
		<< (((duration.count() / 1000000) / 60.0) - ((duration.count() / 1000000) / 60)) * 60 << "-Sec" << endl;

	destroyAllWindows();
	namedWindow("Finalpath", WINDOW_NORMAL);
	resizeWindow("Finalpath", 600, 600);
	imshow("Finalpath", Finalpath);

	namedWindow("NN", WINDOW_NORMAL);
	resizeWindow("NN", 800, 800);
	imshow("NN", frame1);
	waitKey(0);


	return 0;

}


//------------------------------------------TrackAll function----------------------------------//
void trackAll(const char* videoFilename)
{
	VideoCapture cap(videoFilename);
	char* temp = (char*)videoFilename;

	cap.set(CAP_PROP_FPS, 0.5);
	cap.read(frame);
	//cv::Rect myROI(0, 0, 192*4, 108*4);
	//frame = frame(myROI);

	cap.read(Finalpath);
	//Finalpath = Finalpath(myROI);

	//taking frame 10,15 and applying MOG2 operation to find the mask of all the moving sperms
	cap.set(CAP_PROP_POS_FRAMES, 10);
	GaussianBlur(frame, frame, Size(5, 5), 0, 0, BORDER_DEFAULT);
	cvtColor(frame, frame, CV_BGR2GRAY);
	threshold(frame, frame, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);
	pMOG2->apply(frame, fgMaskMOG2);
	//imshow("PP1", fgMaskMOG2);

	cap.read(frame);
	//frame = frame(myROI);
	cap.set(CAP_PROP_POS_FRAMES, 15);
	GaussianBlur(frame, frame, Size(5, 5), 0, 0, BORDER_DEFAULT);
	cvtColor(frame, frame, CV_BGR2GRAY);
	threshold(frame, frame, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);
	pMOG2->apply(frame, fgMaskMOG2);
	//imshow("PP2", fgMaskMOG2);
	//waitKey(0);

	//Ptr<Tracker> tracker;
	//tracker = TrackerBoosting::create();
	//Ptr<TrackerKCF> tracker = TrackerKCF::create();

	Ptr<TrackerMIL> tracker = cv::TrackerMIL::create();

	//Ptr<TrackerGOTURN> tracker = cv::TrackerGOTURN::create();

	//Ptr<TrackerMedianFlow> tracker = cv::TrackerMedianFlow::create();

	//Ptr<TrackerMOSSE> tracker = cv::TrackerMOSSE::create();
	//Ptr<TrackerTLD> tracker = cv::TrackerTLD::create();
	//Ptr<TrackerCSRT> tracker = cv::TrackerCSRT::create();

	//tracker = Tracker::create("KCF");

	vector<Rect2d>bboxs;//(287, 23, 86, 320);

	cvtColor(fgMaskMOG2, colorFgMask, COLOR_GRAY2BGR);
	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;
	vector<Point2f>moments;
	findContours(fgMaskMOG2, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));

	Mat contr = Mat::zeros(fgMaskMOG2.size(), CV_8UC3);
	vector<int> V;

	for (int i = 0; i < contours.size(); i++)
	{
		//Apllying area contraint to remove the small noises in the mask
		if (contourArea(contours[i]) > 100)
		{
			drawContours(contr, contours, i, Scalar(255, 255, 0), FILLED);

			//Finding centroid of each contour and pushing it in the moments vector
			moments.push_back(calculateBlobCentroid(contours[i]));
			circle(frame, moments[moments.size() - 1], 3, Scalar(0, 255, 255), -1, 8, 0);
			V.push_back(i);

		}
	}
	//imshow("con", contr);

	for (int i = 0 ;i < moments.size();i++)
	{
		float length = 50;

		//Defining bounding box around each moving sperm using the moment we found earlier
		Rect2d bbox(moments[i].x - length / 2, moments[i].y - length / 2, length, length);
		bboxs.push_back(bbox);

		//Now tracking each sperm individually 
		trackIndi(i, bbox, temp , contours , V[i]);
		cout << "Percentage Completion:            \t" << (float)i * 100.0 / moments.size() << "%" << endl << endl;
	}

	cout << "--------------------------------------------------------------" << endl
		<< "Count:" << moments.size() << endl
		<< "Fast Moving: " << moments.size() - slowSperm.size() << endl
		<< "Slow Moving: " << slowSperm.size() << endl
		<< "Percentage motile: " << ((moments.size() - slowSperm.size()) / float(moments.size())) * 100 << endl
		<< "--------------------------------------------------------------" << endl << endl;
}


//------------------------Calculating distance between two points function--------------------//
float dist(Point2f p, Point2f q)
{
	float d;
	d = sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));
	return d;
}


//---------------------Checking if sperm is fast-moving or slow-moving--------------------------//
bool checkRange(vector<Point2f> travelled)
{
	float thresholdDist = 10;
	float tempMaxDist = 0;
	for (int i = 0;i < travelled.size();i++)
	{
		for (int j = i;j < travelled.size();j++)
		{
			if (dist(travelled[i], travelled[j]) > tempMaxDist)
			{
				tempMaxDist = dist(travelled[i], travelled[j]);
			}
		}
	}

	cout << "tempMaxDist(Displacement): " << tempMaxDist << endl;
	if (tempMaxDist > thresholdDist)
	{
		return true;
	}
	else
	{
		return false;
	}
}

//-----------------------Tracking individual particle-------------------------------------------//
void trackIndi(int i, Rect2d bbox, char* videoFilename , vector<vector<Point>> contours , int t)
{
	//for Different color of each sperm path
	color = Scalar(rng.uniform(0, 10000) % 255, (rng.uniform(0, 10000)) % 255, (rng.uniform(0, 10000) % 255));

	//Ptr<Tracker> tracker;
	//tracker = TrackerBoosting::create();
	//Ptr<TrackerKCF> tracker = TrackerKCF::create();
	Ptr<TrackerMIL> tracker =  cv::TrackerMIL::create();

	//Ptr<TrackerGOTURN> tracker = cv::TrackerGOTURN::create();
	//Ptr<TrackerMOSSE> tracker = cv::TrackerMOSSE::create();
	//Ptr<TrackerTLD> tracker = cv::TrackerTLD::create();
	//Ptr<TrackerCSRT> tracker = cv::TrackerCSRT::create();

	//Ptr<TrackerMedianFlow> tracker = cv::TrackerMedianFlow::create();


	stringstream ss;
	ss << i;
	ss << ".avi";
	VideoCapture cap(videoFilename);
	cap.set(CAP_PROP_FPS, 5);
	cap.read(frame);

	//cv::Rect myROI(0, 0, 192*4,108*4 );
	//frame = frame(myROI);

	//drawing rectangle around the sperm which is being tracked
	rectangle(frame, bbox, Scalar(255, 0, 0), 2, 1);

	bool is_inside = false;

	//Checking if the sperm is inside the Video frame or not
	if ((bbox.x > 0) && (bbox.y > 0) && (bbox.x + 100 < frame.size().width) && (bbox.y + 100 < frame.size().height))
	{
		is_inside = true;
	}

	imshow("fg", frame);
	int index = 0;

	if (is_inside)
	{
		tracker->init(frame, bbox);
		while ((cap.read(frame)) && (cap.get(CAP_PROP_POS_FRAMES) * 1.0 / cap.get(CAP_PROP_FPS) < 1))
		{
			//cv::Rect myROI(0, 0, 192 * 4, 108 * 4);
			//frame = frame(myROI);
			//Skiping frames to decrease Runtime of the program 
			//Since skipping frames won't affect the output
			if (index % 2 == 0)
			{
				bool ok = tracker->update(frame, bbox);
				if (ok)
				{
					rectangle(frame, bbox, Scalar(255, 0, 0), 2, 1);
					Point2f center_of_rect = (bbox.br() + bbox.tl()) * 0.5;
					travelled.push_back(center_of_rect);

					//Checking Sperm type fast-moving or slow-moving
					//On the basis of the displacement done by the sperm
					if (travelled.size() > 10)
					{
						for (int i = 1;i < travelled.size();i++)
						{
							//line(frame, travelled[travelled.size() - i], travelled[travelled.size() - (i + 1)], Scalar(0, 255, 0), 2, 8, 0);
							line(Finalpath, travelled[travelled.size() - i], travelled[travelled.size() - (i + 1)], color, 2, 8, 0);
						}
					}
				}


				imshow("fg", frame);
				char k = waitKey(10);
				if (k == 'n')
				{
					break;
				}
			}
			index += 1;

		}
	}
	else
	{
		cout << "Not inside" << endl;
	}

	bool isFast = checkRange(travelled);
	if (isFast)
	{
		fastSperm.push_back(i);
		drawContours(frame1, contours, t , Scalar(0, 0, 255), FILLED);
	}
	else
	{
		slowSperm.push_back(i);
		drawContours(frame1, contours, t, Scalar(0, 255 , 0), FILLED);
	}

	travelled.clear();
}



//-----------------------------------Calculating centroid of the sperm contour------------------------//
Point calculateBlobCentroid(vector<Point>blob)
{
	cv::Moments mu = cv::moments(blob);
	cv::Point centroid = cv::Point(mu.m10 / mu.m00, mu.m01 / mu.m00);

	return centroid;
}